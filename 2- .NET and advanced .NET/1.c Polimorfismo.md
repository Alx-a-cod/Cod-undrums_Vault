Il **polimorfismo** è uno dei 4 pilastri della Programmazione Orientata agli Oggetti (OOP).  

La parola deriva dal greco **"poli" (molti) + "morfo" (forme)** → “molte forme”.  

In C# significa che **un metodo, un oggetto o un’interfaccia può comportarsi in modi diversi a seconda del contesto**, mantenendo però la **stessa interfaccia esterna**.

---
## Tipi di polimorfismo in C#

### 1. Polimorfismo statico (compile-time)

- Si ottiene tramite **overloading** (sovraccarico).
- L’**overload** (o sovraccarico) è un concetto di **polimorfismo statico** (compile-time) in C#.  
  Permette di avere **più metodi con lo stesso nome**, ma **con firme diverse** (diverso numero o tipo di parametri) all’interno della stessa classe.

- La scelta del metodo da chiamare avviene **a compile-time**.
  
   #### Caratteristiche principali
    - Il metodo deve avere **stesso nome** ma **parametri differenti**:
    - numero di parametri diverso, oppure tipo dei parametri diverso.
    - Il tipo di ritorno **non conta** per distinguere i metodi.
    - Aiuta a scrivere codice **pulito e leggibile**, evitando nomi diversi per funzioni simili.
      
Esempio pratico:

```csharp
public class Calcolatrice
{
    public int Somma(int a, int b) => a + b;
    public double Somma(double a, double b) => a + b;
    public int Somma(int a, int b, int c) => a + b + c;
}

class Program
{
    static void Main()
    {
        var calc = new Calcolatrice();
        Console.WriteLine(calc.Somma(2, 3));       // 5
        Console.WriteLine(calc.Somma(2.5, 3.5));   // 6.0
        Console.WriteLine(calc.Somma(1, 2, 3));    // 6
    }
}
```

---

In C#, il polimorfismo può manifestarsi anche a **runtime** tramite metodi **virtuali/override** o tramite **interfacce**. 
Questi due concetti rientrano nel polimorfismo dinamico (<span style="color: #8392a4">runtime polymorphism</span>).
### 2. Polimorfismo dinamico (override)

Si verifica quando una variabile di tipo **classe base** può riferirsi a oggetti di **classi derivate**.  
- Il metodo chiamato dipende dal **tipo reale dell’oggetto** al momento dell’esecuzione.  
- Si realizza con i modificatori `virtual` (classe base) e `override` (classe derivata).

- La scelta del metodo da eseguire avviene a runtime.

```csharp
public class Animale
{
    public virtual void Verso()
    {
        Console.WriteLine("Suono generico di animale");
    }
}

public class Cane : Animale
{
    public override void Verso()
    {
        Console.WriteLine("Bau Bau!");
    }
}

public class Gatto : Animale
{
    public override void Verso()
    {
        Console.WriteLine("Miao!");
    }
}

class Program
{
    static void Main()
    {
        Animale a1 = new Cane();
        Animale a2 = new Gatto();

        a1.Verso();  // Bau Bau!
        a2.Verso();  // Miao!
    }
}
```

`-->` La chiamata a `Verso()` viene risolta a runtime in base al tipo reale (`Cane` o `Gatto`).

### 3. Polimorfismo tramite interfacce

- Una **interfaccia** definisce un **contratto** di metodi/proprietà che una classe deve implementare.
- Permette di trattare **oggetti diversi in modo uniforme**, anche se appartengono a classi non correlate tra loro.
- Supporta il polimorfismo **senza ereditarietà di classe**, utile per design flessibili e decoupled.

> Una classe può implementare più **interfacce**, ognuna con la sua versione dei metodi.

Permette di trattare **oggetti diversi in maniera uniforme**.

```csharp

public interface IVeicolo
{
    void Muovi();
}

public class Auto : IVeicolo
{
    public void Muovi() => Console.WriteLine("L'auto si muove su strada");
}

public class Barca : IVeicolo
{
    public void Muovi() => Console.WriteLine("La barca naviga sull'acqua");
}

class Program
{
    static void Main()
    {
        IVeicolo v1 = new Auto();
        IVeicolo v2 = new Barca();

        v1.Muovi(); // L'auto si muove su strada
        v2.Muovi(); // La barca naviga sull'acqua
    }
}
```

`-->`  variabili di tipo `IVeicolo` possono contenere qualsiasi oggetto che implementa l’interfaccia, indipendentemente dalla classe concreta.

### Differenze chiave

|Tipo di Polimorfismo|Come si realizza|Quando viene risolto|Esempio|
|---|---|---|---|
|Dinamico (override)|`virtual` / `override`|Runtime|Classe base `Animale`, derivata `Cane`|
|Interfaccia|Implementazione interfaccia|Runtime|Interfaccia `IVeicolo`, classi `Auto`/`Barca`|
## Vantaggi del polimorfismo

- **Flessibilità** → puoi scrivere codice generico che funziona con tipi diversi.
- **Estendibilità** → aggiungere nuove classi derivate senza modificare codice esistente.
-  **Pulizia** → riduce gli if/switch per distinguere i tipi.
-  **Manutenibilità** → più semplice aggiornare e scalare il software.
  
## Sintesi 

>L’**overload** permette di definire più metodi con lo stesso nome,  ma con parametri diversi.  È utile per **metodi simili** con comportamenti leggermente diversi,  migliorando leggibilità e manutenzione del codice.
>Il **polimorfismo dinamico** permette di chiamare il metodo corretto a **runtime** in base al tipo reale dell’oggetto, usando `virtual`/`override`.  
>Il **polimorfismo tramite interfacce** consente di trattare oggetti diversi in maniera uniforme, rispettando un contratto comune, indipendentemente dalla gerarchia delle classi.